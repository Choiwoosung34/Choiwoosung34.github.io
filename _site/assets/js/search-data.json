{"0": {
    "doc": "[백준] 숌 사이 수열",
    "title": "숌 사이 수열",
    "content": "제목: 숌 사이 수열 번호: 1469 푼 날짜: 2024-01-28 . 문제는 여기에서 확인 가능합니다. 문제 내용 보기 (click me!) 문제 . 숌은 N개의 다른 숫자로 구성된 집합 X를 만들었습니다. 이제 길이가 2N인 숌 사이 수열 (S)을 만들려고 합니다. 숌 사이 수열의 정의: . | X에 있는 모든 숫자는 숌 사이 수열 S에 정확히 두 번씩 나타나야 합니다. | X에 있는 숫자 i에 대해, S에서 i가 두 번 나타나는 사이에는 정확히 i개의 숫자가 있어야 합니다. | . 예시: 집합 X가 {1, 2, 3}일 때, 가능한 숌 사이 수열은 {2, 3, 1, 2, 1, 3}입니다. 이 수열은 위 정의를 모두 만족합니다. 문제: 집합 X가 주어졌을 때, 가능한 숌 사이 수열 S를 하나 출력하십시오. ",
    "url": "/docs/algorithm/1469#%EC%88%8C-%EC%82%AC%EC%9D%B4-%EC%88%98%EC%97%B4",
    
    "relUrl": "/docs/algorithm/1469#숌-사이-수열"
  },"1": {
    "doc": "[백준] 숌 사이 수열",
    "title": "입력",
    "content": ". | 첫 번째 줄에는 집합 X의 크기 N이 주어집니다. | 두 번째 줄에는 X에 속하는 수가 공백으로 구분되어 주어집니다. | N의 크기는 8 이하의 자연수입니다. | X의 원소는 0 이상 16 이하의 정수입니다. | . ",
    "url": "/docs/algorithm/1469#section-1",
    
    "relUrl": "/docs/algorithm/1469#section-1"
  },"2": {
    "doc": "[백준] 숌 사이 수열",
    "title": "출력",
    "content": ". | 가능한 숌 사이 수열을 공백으로 구분하여 출력합니다. | 여러 개의 가능한 수열이 있는 경우, 사전 순으로 가장 빠른 수열을 출력합니다. | 가능한 수열이 없는 경우 -1을 출력합니다. | . ",
    "url": "/docs/algorithm/1469#section-2",
    
    "relUrl": "/docs/algorithm/1469#section-2"
  },"3": {
    "doc": "[백준] 숌 사이 수열",
    "title": "예제",
    "content": "입력 1 . 3 1 2 3 . 출력 1 . 2 3 1 2 1 3 . 입력 2 . 1 0 . 출력 2 . 0 0 . 입력 3 . 4 1 2 3 4 . 출력 3 . 2 3 4 2 1 3 1 4 . 입력 4 . 5 1 2 3 4 5 . 출력 4 . -1 . 입력 5 . 2 2 0 . 출력 5 . 2 0 0 2 . 입력 6 . 8 0 4 13 12 8 5 2 14 . 출력 6 . -1 . 풀이 . BLANK = -1 def dfs(count: int, N: int, S: list[int], X: list[int]): if count == N: print(*S) exit() for i in X: if i in S: continue next_idx = S.index(BLANK) if next_idx + i + 1 &gt;= N * 2: break if S[next_idx + i + 1] != BLANK: continue S[next_idx] = i S[next_idx + i + 1] = i dfs(count+1, N, S, X) S[next_idx] = BLANK S[next_idx + i + 1] = BLANK def solve(N: int, X: list[int]): S = [BLANK] * (N * 2) dfs(0, N, S, X) print(-1) N = int(input()) X = sorted(list(map(int, input().split()))) solve(N, X) . 언어: Python . 알고리즘: DFS . 시간 복잡도: O(N!) . 난이도: GOLD 5 . 문제 해설 . 숌 사이 수열을 만드는 문제다. 숌 사이 수열은 아래와 같다. 서로 N 개로 이루어진 X의 요소가 모두 2번씩 존재해야 하고, 어떤 수가 i 라면, i 와 i사이에는 어떤 수가 i 개 등장해야 된다. Example1 When: N = 2 X = {2, 0} Then: S = {2, 0, 0, 2} Example2 When: N = 3 X = {2, 3, 1} Then: S = {2, 3, 1, 2, 1, 3} 또는 {3, 1, 2, 1, 3, 2} . 2번째 예시처럼 가능한 경우의 수가 여러개일 수 있다. 그런경우 사전순으로 가장 앞에 있는걸 출력해야 한다. 나는 아래와 같이 접근했다. | 필요한 값 N, X 를 입력받는다. | N = int(input()) X = sorted(list(map(int, input().split()))) . | X 는 오름차순으로 정렬해서 받아줬다. | 사전순으로 가장 빠른것부터 시도하기 위함. | . | 만들어야 될 수열 S 는 빈칸으로 채워준다. | BLANK = -1 S = [BLANK] * (N * 2) # S: {-1, -1, -1, -1, -1, -1} . | . | 그 후 사전순서로 앞부터 수열 S를 채우는 함수를 재귀적으로 호출한다. | X를 정렬했으므로, 사전 순서로 채우는게 보장된다. | 아래와 같이 동작한다. | 입력값: N = 3 X = {1, 2, 3} S = {-1, -1, -1, -1, -1, -1} 동작: i = 1, S = {1, -1, 1, -1, -1, -1} ㄴ i = 2, S = {1, 2, 1, -1, 2, -1} ㄴ i = 3, S = {1, 2, 1, 3, 2, -1} . 3 # 범위를 벗어남 불가능 ㄴ i = 3, S = {1, 3, 1, -1, 3, -1} ㄴ i = 2, S = {1, 3, 1, 2, 3, -1} 2 # 범위를 벗어남 불가능 i = 2, S = {2, -1, -1, 2, -1, -1} ㄴ i = 1, S = {2, 1, -1, \"2! 1!\", -1, -1} # 채워야 할 곳에 2 가 있어서 불가능 ㄴ i = 3, S = {2, 3, -1, 2, -1, 3} ㄴ i = 1, S = {2, 3, 1, 2, 1, 3} # 종료 조건을 타고 탈출함 정답 : 2 3 1 2 1 3 . | . | . 시간 복잡도 . 위 코드는 한가지를 고르고 나머지 가능한 경우를 하나씩 줄여가며 재귀적으로 탐색하고 있다. 즉 N 팩토리얼이다. N 이 최대 8 까지 주어지므로 최악의 경우 8! = 40320 으로 2초내에 충분이 풀이가 가능하다고 생각되어, 풀었고 풀이에 성공했다. 주의 할 점 . 정렬에 대해 주의하자. 만약 여러 개일 경우 사전 순으로 가장 빠른 것을 출력한다. 이 부분이 애매했다. 처음에는 계속 문자열로 처리를 해서 계속 틀렸다. 즉 문제에서 요구하는 조건을 충족하려면 반드시 숫자로 비교해야 한다. 위 이미지 처럼 정렬을 문자열로 하면, ‘10’ 이 가장 사전순으로 앞이다. 근데 사전순이라면 문자열로 기준잡는거 아닌가… . ",
    "url": "/docs/algorithm/1469#section-3",
    
    "relUrl": "/docs/algorithm/1469#section-3"
  },"4": {
    "doc": "[백준] 숌 사이 수열",
    "title": "[백준] 숌 사이 수열",
    "content": " ",
    "url": "/docs/algorithm/1469",
    
    "relUrl": "/docs/algorithm/1469"
  },"5": {
    "doc": "EAFP (허락보다 용서가 쉽다)",
    "title": "“Easier to Ask Forgiveness than Permission”",
    "content": "나는 타 언어로 개발을 시작하여 사실 LBYL 스타일이 더 익숙했었지만, 파이썬 개발자들에게는 EAFP 코딩 스타일이 꽤 유명하며 일반적인 방법이다. 왜 그럴까? 그에 대한 내용을 다룬다. 아래에서 다루겠지만, 당연히 모든 상황에 반드시 EAFP 가 적용되야 하는 것은 아니다! . 1. 어디에서 유례된 개념인가 . “용서를 구하는게 허락을 받는것 보다 쉽다” - 그레이스 호퍼 [source] . 초기 프로그래밍 세계에 뛰어난 공헌을 한 컴퓨터 과학자인 Grace Hopper는 위와 같은 명언과 지혜를 남겼다. EAFP는 위 명언에서 출발한 개념으로 볼 수 있다. 해당 명언에 대한 자세한 의미등은 본 문서의 주제와 다르므로 다루지 않는다. 다만 유례는 Grace Hopper 에게서 왔다. 2. 코드 스타일에서의 EAFP . [작성 중] . ",
    "url": "/docs/python/pythonic/eafp#easier-to-ask-forgiveness-than-permission",
    
    "relUrl": "/docs/python/pythonic/eafp#easier-to-ask-forgiveness-than-permission"
  },"6": {
    "doc": "EAFP (허락보다 용서가 쉽다)",
    "title": "EAFP (허락보다 용서가 쉽다)",
    "content": ". ",
    "url": "/docs/python/pythonic/eafp",
    
    "relUrl": "/docs/python/pythonic/eafp"
  },"7": {
    "doc": "About Me",
    "title": "About Me",
    "content": ". About Me 👋 . Hi, I’m a passionate developer with a knack for problem-solving and a love for creating innovative software solutions . | 🔭 I’m currently working on Cafe24 Corp. | 🌱 I’m currently learning Python, Algorithm, LLM. | | . 🧑🏻‍🔧 Tech Stack 🧑🏻‍🔧 . | Language . | . | Framework . | . | DB . | . | ETC . | . | . 🙋‍♂️ Contact Info . | name: 최우성 (CHOI WOOSUNG) | mobile : 010-9268-3936 | email : myhouse34@naver.com | . 🚀 Projects . | Project1: TODO | . ",
    "url": "/about",
    
    "relUrl": "/about"
  },"8": {
    "doc": "알고리즘",
    "title": "알고리즘 문제 풀이",
    "content": "매일 문제를 풀고 풀이를 정리하면서 공부해보자. ",
    "url": "/docs/algorithm#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/algorithm#알고리즘-문제-풀이"
  },"9": {
    "doc": "알고리즘",
    "title": "알고리즘",
    "content": " ",
    "url": "/docs/algorithm",
    
    "relUrl": "/docs/algorithm"
  },"10": {
    "doc": "자식메뉴1",
    "title": "Menu 3",
    "content": " ",
    "url": "/docs/error_archive/child#menu-3",
    
    "relUrl": "/docs/error_archive/child#menu-3"
  },"11": {
    "doc": "자식메뉴1",
    "title": "자식메뉴1",
    "content": " ",
    "url": "/docs/error_archive/child",
    
    "relUrl": "/docs/error_archive/child"
  },"12": {
    "doc": "자식메뉴1",
    "title": "Menu 3",
    "content": " ",
    "url": "/docs/project/child#menu-3",
    
    "relUrl": "/docs/project/child#menu-3"
  },"13": {
    "doc": "자식메뉴1",
    "title": "자식메뉴1",
    "content": " ",
    "url": "/docs/project/child",
    
    "relUrl": "/docs/project/child"
  },"14": {
    "doc": "오픈소스1",
    "title": "오픈소스",
    "content": " ",
    "url": "/docs/open_sourece/child#%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4",
    
    "relUrl": "/docs/open_sourece/child#오픈소스"
  },"15": {
    "doc": "오픈소스1",
    "title": "오픈소스1",
    "content": " ",
    "url": "/docs/open_sourece/child",
    
    "relUrl": "/docs/open_sourece/child"
  },"16": {
    "doc": "CS",
    "title": "CS",
    "content": " ",
    "url": "/docs/study/cs",
    
    "relUrl": "/docs/study/cs"
  },"17": {
    "doc": "에러저장소",
    "title": "에러저장소",
    "content": " ",
    "url": "/docs/error_archive",
    
    "relUrl": "/docs/error_archive"
  },"18": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": ". 해당 블로그는 공부하는거나 문제 해결했던 부분에 대해 경험이나 배운점을 아카이브 해놓는 형식으로 정리하는 블로그입니다. 여담으로 블로그 도메인부터 파이썬 최고수 닷컴인데 진짜 최고수는 아니고 성이 최씨이고 파이썬 좀 잘하고 싶어서 그렇게 지었습니다. 블로그 하면서 진짜 최고수가 되는게 목표입니다. 2024-01 시작 . ",
    "url": "/",
    
    "relUrl": "/"
  },"19": {
    "doc": "오픈소스",
    "title": "오픈소스",
    "content": " ",
    "url": "/docs/open_sourece",
    
    "relUrl": "/docs/open_sourece"
  },"20": {
    "doc": "프로젝트",
    "title": "프로젝트",
    "content": " ",
    "url": "/docs/project",
    
    "relUrl": "/docs/project"
  },"21": {
    "doc": "Python",
    "title": "Python",
    "content": "파이썬과 관련된 주제에 대한 메뉴 . ",
    "url": "/docs/python",
    
    "relUrl": "/docs/python"
  },"22": {
    "doc": "Pythonic",
    "title": "파이썬스러움에 대한 고찰",
    "content": ". Pythonic (파이썬스러움) . 파이썬스러움이란 한마디로 표현하긴 어렵다. 왜냐하면 파이썬 그 자체가 Pythonic 하다. 파이썬스러움에 대한 블로그를 찾아보면 문법적으로만 설명한 글이 많았다. | e.g.) 리스트 컴프리헨션을 쓰세요. | . 하지만 Pythonic은 단순 코드 스타일뿐만 아니라, 파이썬에 대한 철학이 녹아있는 개념이라고 생각한다. 정말 파이썬스럽게 작성하려면 왜 그렇게 써야 하며, 언제 어떻게 써야 하는지에 대해 이해하고 고민이 필요하다. 그래서 파이썬스러운 개념들에 대해 깊게 연구하고 고민하여, 나의 생각을 정리한 문서를 작성해나갈 예정이다. 2024-01 . ",
    "url": "/docs/python/pythonic#%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%8A%A4%EB%9F%AC%EC%9B%80%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0",
    
    "relUrl": "/docs/python/pythonic#파이썬스러움에-대한-고찰"
  },"23": {
    "doc": "Pythonic",
    "title": "Pythonic",
    "content": " ",
    "url": "/docs/python/pythonic",
    
    "relUrl": "/docs/python/pythonic"
  },"24": {
    "doc": "공부",
    "title": "Study",
    "content": "공부하는 내용을 정리하는 메뉴입니다. ",
    "url": "/docs/study#study",
    
    "relUrl": "/docs/study#study"
  },"25": {
    "doc": "공부",
    "title": "공부",
    "content": " ",
    "url": "/docs/study",
    
    "relUrl": "/docs/study"
  }
}
